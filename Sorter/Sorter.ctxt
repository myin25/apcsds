#BlueJ class context
comment0.target=Sorter
comment0.text=\n\ Sorter\ contains\ various\ implementations\ of\ sorting\ algorithms,\ including\:\n\ \ \ \ \ \ \ selectionSort(Comparable[]\ a)\n\ \ \ \ \ \ \ insertionSort(Comparable[]\ a)\n\ \ \ \ \ \ \ mergeSort(Comparable[]\ a)\n\ \ \ \ \ \ \ quickSort(Comparable[]\ a)\n\ Other\ methods\ in\ this\ class\ include\:\n\ \ \ \ \ \ \ main(String[]\ args)\n\ \ \ \ \ \ \ Sorter()\n\ \ \ \ \ \ \ indexOfMin(Comparable[]\ a,\ int\ startIndex)\n\ \ \ \ \ \ \ insert(Comparable[]\ a,\ int\ nextIndex)\n\ \ \ \ \ \ \ mergesortHelp(Comparable[]\ a,\ int\ lowIndex,\ int\ highIndex)\n\ \ \ \ \ \ \ merge(Comparable[]\ a,\ int\ lowIndex,\ int\ midIndex,\ int\ highIndex)\n\ \ \ \ \ \ \ partition(Comparable[]\ a,\ int\ lowIndex,\ int\ highIndex)\n\ \ \ \ \ \ \ quicksortHelp(Comparable[]\ a,\ int\ lowIndex,\ int\ highIndex)\n\ @author\ Anu\ Datar\n\ @author\ Melody\ Yin\n\ @version\ 2-24-22\n
comment1.params=args
comment1.target=void\ main(java.lang.String[])
comment1.text=\n\ main\ method\ instantiates\ a\ sorter\ instance\n\ Usage\:\ called\ directly\ by\ the\ IDE\ or\ when\ Java\ is\ launched\ \n\ ------------------------------------------\n\ Creates\ a\ Sorter\ object,\ but\ calls\ no\ methods\ from\ Sorter\ \n\ because\ the\ GUI\ SortDisplay\ calls\ sort\ methods\ in\ Sorter\n\ \n\ @param\ args\ an\ array\ of\ arguments\ for\ legacy\ command\ line\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ the\ values\ are\ not\ used\n
comment10.params=a
comment10.target=void\ quicksort(java.lang.Comparable[])
comment10.text=\ \ \ \ \ \n\ Method\:\ quicksort()\n\ Usage\:\ sorter.quicksort(inputArray)\n\ -------------------------------------\n\ quicksort()\ does\ not\ actual\ do\ the\ sorting,\n\ just\ calls\ quicksortHelp\ with\ parameters\ (a,\ 0,\ a.length-1),\n\ which\ does\ the\ actual\ quick\ sorting\n\ \n\ Postcondition\:\ a[lowIndex]\ to\ a[highIndex]\ are\ in\ increasing\ order\n\ @param\ a\ -\ array\ of\ comparable\ elements\ to\ be\ sorted\ with\ quick\ sort\n
comment11.params=a\ lowIndex\ highIndex
comment11.target=void\ quicksortHelp(java.lang.Comparable[],\ int,\ int)
comment11.text=\n\ Method\:\ quicksortHelp()\n\ Usage\:\ quicksortHelp(a,\ low,\ high)\n\ ------------------------------------------\n\ Quick\ sorting\ is\ a\ recursive\ sorting\ algorithm\ that\ sets\ a\ pivot\ point\n\ \ \ \ \ \ (lowIndex\ in\ this\ case)\ and\ calls\ partition\ which\ performs\ rough\ \n\ \ \ \ \ \ sort\:\ puts\ every\ element\ less\ than\ pivot\ left\ of\ pivot,\ and\ every\ \n\ \ \ \ \ \ element\ bigger\ than\ pivot\ right\ of\ pivot.\ Then,\ quicksortHelp\ is\ \n\ \ \ \ \ \ called\ on\ the\ sections\ left\ &\ right\ of\ the\ pivot\ point\n\ Base\ case\:\ section\ of\ the\ array\ given\ by\ low\ &\ highIndex\ has\ 1\ element\n\ \ \ \ \ \ \ \ \ (high\ <\=\ low),\ which\ is\ "sorted"\ by\ definition.\ Therefore,\ \n\ \ \ \ \ \ \ \ \ nothing\ is\ done\ to\ it.\n\ Recursive\ reduction\:\ the\ element\ at\ lowIndex\ is\ sorted\ as\ the\ pivot\ \n\ \ \ \ \ \ \ \ \ using\ partition()\ and\ the\ index\ where\ it\ lands\ is\ returned.\n\ \ \ \ \ \ \ \ \ The\ array\ is\ then\ divided\ from\ (low,pivot-1)\ &\ (pivot+1,high)\n\ \ \ \ \ \ \ \ \ because\ index\ pivot\ is\ already\ sorted,\ and\ quicksortHelp\ is\ \n\ \ \ \ \ \ \ \ \ used\ again\ on\ sections\ left\ &\ right\ of\ the\ pivot\ element.\n\ \n\ Postcondition\:\ a[lowIndex]\ to\ a[highIndex]\ are\ in\ increasing\ order\n\ @param\ a\ -\ array\ of\ comparable\ elements\ to\ be\ sorted\ with\ quick\ sort\n\ @param\ lowIndex\ -\ beginning\ index\ of\ section\ of\ array\ to\ be\ sorted\n\ @param\ highIndex\ -\ ending\ index\ of\ section\ of\ array\ to\ be\ sorted\n
comment12.params=a\ lowIndex\ highIndex
comment12.target=int\ partition(java.lang.Comparable[],\ int,\ int)
comment12.text=\n\ Method\ partition\n\ Usuage\:\ int\ pivotIndex\ \=\ partition(a,\ lowIndex,\ highIndex)\n___________________________________________________________\n\nReturns\ the\ index\ of\ the\ pivot\ element\ defined\ as\ follows\:\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ All\ elements\ on\ the\ left\ side\ of\ the\ pivot\ (from\ lowIndex)\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ are\ less\ than\ or\ equal\ to\ the\ pivot.\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ All\ elements\ on\ the\ right\ side\ of\ the\ pivot\ \n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (through\ highIndex)\ are\ greater\ than\ or\ equal\ to\ the\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pivot.\n\ The\ computation\ is\ performed\ in\ place.\n\ @param\ a\ the\ array\ to\ partion\n\ @param\ lowIndex\ is\ the\ index\ of\ the\ start\ of\ the\ part\ of\ array\ a\ to\n\ \ \ \ \ \ \ consider\n\ @param\ highIndex\ is\ the\ index\ of\ the\ end\ of\ the\ part\ of\ array\ a\ to\ \n\ \ \ \ \ \ \ consider\n\ @return\ the\ index\ of\ the\ pivot\ element\ in\ array\ a\n
comment2.params=
comment2.target=Sorter()
comment2.text=\n\ Constructor\:\ Sorter()\n\ Usage\:\ \ Sorter\ aSorter\ \=\ new\ Sorter()\n\ ________________________________________\n\ Constructor\ for\ Sorter\ objects.\ \ Creates\ a\ new\ display,\ which\ controls\n\ all\ of\ the\ sorting\ by\ means\ of\ call-backs\ to\ this\ class.\n
comment3.params=a\ startIndex
comment3.target=int\ indexOfMin(java.lang.Comparable[],\ int)
comment3.text=\n\ Method\:\ indexOfMin()\n\ Usage\:\ aSorter.indexOfMin(Comparable[]\ a,\ int\ startIndex);\n\ ________________________________________\n\ Takes\ in\ an\ array\ of\ Comparable\ objects\ and\ a\ starting\ index\ and\ finds\n\ \ \ \ \ \ the\ index\ of\ the\ smallest\ value\ in\ the\ array\ by\ iterating\n\ \ \ \ \ \ through\ each\ element\ in\ the\ array.\ The\ range\ of\ elements\ being\n\ \ \ \ \ \ considered\ starts\ at\ startIndex\ and\ goes\ until\ the\ end\ of\ the\ \n\ \ \ \ \ \ array.\n\ @param\ a\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ the\ array\ that\ we\ are\ looking\ for\ the\ min\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ value\ in\n\ @param\ startIndex\ \ \ \ \ \ \ \ the\ starting\ index\ for\ iteration\n\ @precondition\ 0\ <\ startIndex\ <\ a.length\n\ @return\ the\ index\ of\ the\ smallest\ value;\ if\ the\ length\ of\ the\ array\ is\n\ \ \ \ \ \ zero,\ return\ -1.\n
comment4.params=a
comment4.target=void\ selectionSort(java.lang.Comparable[])
comment4.text=\n\ Method\:\ selectionSort(Comparable[]\ a);\n\ Usage\:\ aSorter.selectionSort(Comparable[]\ a);\n\ ________________________________________\n\ Takes\ in\ an\ array\ of\ Comparable\ objects\ and\ sorts\ them\ using\ selection\n\ \ \ \ \ \ sort,\ which\ iterates\ through\ each\ possible\ start\ index,\ beginning\n\ \ \ \ \ \ with\ 0\ and\ ending\ at\ a.length\ -\ 1\ and\ finds\ the\ minimum\ for\ that\ \n\ \ \ \ \ \ subarray.\ It\ then\ swaps\ that\ minimum\ with\ the\ start\ index.\ This\ \n\ \ \ \ \ \ process\ repeats\ until\ the\ start\ index\ is\ a.length\ -\ 1.\n\ @param\ a\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ the\ array\ that\ we\ are\ sorting\n\ @postcondition\ the\ given\ array\ is\ sorted\n
comment5.params=a\ nextIndex
comment5.target=void\ insert(java.lang.Comparable[],\ int)
comment5.text=\n\ Method\:\ insert()\n\ Usage\:\ aSorter.insert(Comparable[]\ a,\ int\ nextIndex);\n\ \ \ \ \ \ Typically\ used\ in\ insertionSort()\ in\ order\ to\ 'slide'an\ element\ \n\ \ \ \ \ \ into\ place.\n\ ________________________________________\n\ Takes\ in\ an\ array\ of\ Comparable\ objects.\ Given\ an\ object\ at\ index\n\ \ \ \ \ \ nextIndex,\ insert\ iterates\ through\ each\ item\ in\ the\ array\ before\n\ \ \ \ \ \ nextIndex\ +\ 1\ and\ 'slides'\ the\ object\ until\ it\ finds\ a\ place\ such\n\ \ \ \ \ \ that\ the\ section\ of\ the\ array\ from\ 0\ to\ nextIndex\ (inclusive)\ is\ \n\ \ \ \ \ \ in\ strictly\ increasing\ order.\n\ @param\ a\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ the\ array\ that\ we\ are\ inserting\ the\ element\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ into\n\ @param\ nextIndex\ \ \ \ \ \ \ \ \ the\ element\ of\ the\ item\ we\ are\ 'sliding'\ into\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ place\n\ @precondition\ All\ of\ the\ elements\ in\ the\ array\ before\ nextIndex\ will\ \n\ \ \ \ \ \ already\ appear\ in\ increasing\ order\ and\ the\ remaining\ elements\ \n\ \ \ \ \ \ will\ appear\ in\ random\ order.\ nextIndex\ is\ within\ the\ index\ bounds\n\ \ \ \ \ \ of\ the\ array.\ a\ has\ been\ initalized.\n\ @postcondition\ The\ element\ at\ nextIndex\ will\ be\ inserted\ into\ its\ \n\ \ \ \ \ \ proper\ place\ in\ subarray\ in\ such\ a\ way\ that\ that\ the\ section\ of\ \n\ \ \ \ \ \ the\ array\ up\ to\ nextIndex\ (inclusive)\ will\ be\ sorted\ in\ ascending\n\ \ \ \ \ \ order.\n
comment6.params=a
comment6.target=void\ insertionSort(java.lang.Comparable[])
comment6.text=\n\ Method\:\ insertionSort()\n\ Usage\:\ aSorter.insertionSort(Comparable[]\ a);\n\ ________________________________________\n\ Takes\ in\ an\ array\ of\ Comparable\ objects\ and\ sorts\ them\ using\ insertion\n\ \ \ \ \ \ sort.\ It\ inserts\ each\ element\ of\ the\ array\ into\ a\ growing\ \n\ \ \ \ \ \ sequence\ of\ sorted\ values.\ Insertion\ sort\ works\ by\ assuming\ that\n\ \ \ \ \ \ the\ front\ part\ of\ the\ list\ is\ always\ sorted,\ taking\ the\ first\ \n\ \ \ \ \ \ item\ from\ the\ part\ of\ the\ list\ that\ is\ assumed\ to\ be\ unsorted,\ \n\ \ \ \ \ \ and\ inserting\ it\ into\ its\ proper\ place\ by\ 'sliding'\ each\ item\ \n\ \ \ \ \ \ larger\ than\ it\ one\ position\ to\ the\ right.\ When\ the\ correct\ spot\ \n\ \ \ \ \ \ for\ the\ item\ is\ determined\ (when\ i\ is\ an\ index\ such\ that\ \n\ \ \ \ \ \ array[i\ -\ 1]\ is\ either\ out\ of\ bounds\ or\ less\ than/equal\ to\ \n\ \ \ \ \ \ array[i]\ and\ array[i\ +\ 1]\ is\ either\ out\ of\ bounds\ or\ larger\ than\n\ \ \ \ \ \ array[i]),\ the\ item\ is\ added\ there.\ The\ insertion\ of\ the\ item\ in\ \n\ \ \ \ \ \ its\ correct\ place\ in\ the\ sorted\ portion\ of\ the\ array\ is\ \n\ \ \ \ \ \ implemented\ using\ the\ insert()\ method.\n\ @param\ a\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ the\ array\ that\ we\ are\ sorting\n\ @postcondition\ The\ given\ array\ is\ sorted\ in\ ascending\ order.\n
comment7.params=a
comment7.target=void\ mergesort(java.lang.Comparable[])
comment7.text=\n\ Method\:\ mergesort()\n\ Usage\:\ aSorter.mergesort(Comparable[]\ a);\n\ ________________________________________\n\ Sorts\ an\ array\ using\ mergesort.\ Mergesort\ works\ like\ this\:\ If\ the\ \n\ \ \ \ \ \ length\ of\ the\ given\ array\ is\ 1\ or\ less,\ return\ the\ array.\ If\ the\ \n\ \ \ \ \ \ length\ of\ the\ given\ array\ is\ larger\ than\ 1,\ then\ split\ the\ array\n\ \ \ \ \ \ in\ two\ equal\ halves\ (or\ as\ equal\ as\ possible\ if\ the\ number\ of\ \n\ \ \ \ \ \ elements\ is\ odd)\ and\ call\ mergesort\ on\ those\ halves\ to\ sort\ them.\n\ \ \ \ \ \ After\ this,\ merge\ the\ now\ sorted\ halves\ by\ repeatedly\ comparing\n\ \ \ \ \ \ the\ first\ items\ of\ each\ half\ and\ moving\ the\ smaller\ of\ the\ two\n\ \ \ \ \ \ to\ the\ front\ of\ the\ array.\ Once\ one\ of\ the\ halves\ runs\ out\ of\n\ \ \ \ \ \ items\ to\ compare,\ add\ all\ the\ remaining\ items\ in\ the\ other\ half\n\ \ \ \ \ \ to\ the\ array.\ You\ keep\ repeating\ this\ process\ recursively\ until\n\ \ \ \ \ \ the\ original\ array\ given\ by\ the\ user\ is\ sorted.\ mergesort()\n\ \ \ \ \ \ itself\ simply\ calls\ on\ a\ helper\ method,\ which\ is\ the\ actual\n\ \ \ \ \ \ implementation\ of\ the\ algorithm.\ The\ reason\ for\ this\ is\ that\ \n\ \ \ \ \ \ mergesort()\ only\ has\ one\ parameter,\ the\ array\ to\ sort,\ in\ order\n\ \ \ \ \ \ to\ make\ the\ user's\ interactions\ with\ the\ function\ more\ simple.\n\ @param\ a\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ the\ array\ that\ we\ are\ sorting\n\ @postcondition\ the\ array\ a\ is\ now\ sorted\ in\ ascending\ order.\n
comment8.params=a\ lowIndex\ highIndex
comment8.target=void\ mergesortHelp(java.lang.Comparable[],\ int,\ int)
comment8.text=\n\ Method\:\ mergesortHelp()\n\ Usage\:\ mergesortHelp(a,\ int\ lowIndex,\ int\ highIndex);\n\ \n
comment9.params=a\ lowIndex\ midIndex\ highIndex
comment9.target=void\ merge(java.lang.Comparable[],\ int,\ int,\ int)
comment9.text=\n\ method\ merge()\n\ Useage\:\ merge(inputArray,\ lowIndex,\ midIndex,\ highIndex)\n_______________________________________________\n\ Merges\ the\ two\ halves\ of\ the\ input\ array\ into\ one.\ \ The\ method\ assumes\n\ that\ each\ half\ of\ the\ input\ array\ is\ sorted\ as\ follows\:\n\ \n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a[lowIndex]\ to\ a[midIndex]\ are\ in\ increasing\ order.\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a[midIndex\ +\ 1]\ to\ a[highIndex]\ are\ in\ increasing\ order.\n\ The\ method\ creates\ an\ array\ to\ hold\ the\ output.\ \ It\ then\ establishes\ \n\ two\ pointers\ into\ the\ two\ halves\ of\ the\ input\ array.\ \ The\ values\ at\ the\n\ pointer\ locations\ are\ compared,\ and\ the\ smallest\ is\ added\ to\ the\ output\n\ array.\ \ The\ corresponding\ pointer\ is\ then\ increased\ by\ one.\ \ In\ the\ event\n\ either\ half\ becomes\ empty,\ the\ remaining\ values\ are\ copied\ to\ the\ output\n\ array.\n\ Postcondition\:\ a[lowIndex]\ to\ a[highIndex]\ are\ in\ increasing\ order.\n\n\ @param\ a\ is\ the\ input\ array\ of\ Comparable\ values\n\ @param\ lowIndex\ is\ the\ index\ into\ the\ array\ a\ corresponding\ to\ the\ \n\ \ \ \ \ \ \ beginning\ of\ the\ first\ half\ of\ the\ array\ to\ merge\n\ @param\ midIndex\ is\ the\ index\ of\ the\ last\ value\ in\ the\ first\ half\ of\ the\n\ \ \ \ \ \ \ array\n\ @param\ highIndex\ is\ the\ index\ of\ the\ last\ value\ in\ the\ second\ half\ of\ \n\ \ \ \ \ \ \ the\ array\n
numComments=13
